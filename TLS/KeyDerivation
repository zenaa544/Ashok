
Step 1: Each side generates a private key

The client picks a random private number a.

The server picks a random private number b.

These are secret and never sent.

Step 2: Each side computes a public key

Using an agreed-upon group (large prime p and generator g for DH, or elliptic curve point G for ECDHE):

Client computes its public value:
A = g^a mod p (for DH)
A = aÂ·G (for ECDHE, point multiplication)

Server computes its public value:
B = g^b mod p
B = bÂ·G

These public values A and B are exchanged.

Step 3: Each side computes the Pre-Master Secret

Now, each side combines their own private key with the other sideâ€™s public key:

Client computes:
S = B^a mod p = (g^b)^a = g^(ab) mod p
(or for ECDHE: S = aÂ·B = aÂ·(bÂ·G) = (ab)Â·G)

Server computes:
S = A^b mod p = (g^a)^b = g^(ab) mod p
(or for ECDHE: S = bÂ·A = bÂ·(aÂ·G) = (ab)Â·G)

ğŸ‘‰ Both arrive at the same value because math guarantees:
g^(ab) mod p = g^(ba) mod p (or (ab)Â·G = (ba)Â·G on elliptic curves).

This shared S is the Pre-Master Secret.

Step 4: Derive the Master Secret

TLS doesnâ€™t use S directly. It runs S through a key derivation function (PRF/HKDF) along with:

Nonces from both client & server hellos

Hashing to mix in freshness

This produces the Master Secret, and from that:

Session keys for encryption (e.g., AES-256-GCM key)

Keys for integrity/MAC (in TLS 1.2) or AEAD (in TLS 1.3, MAC is inside AES-GCM/ChaCha20-Poly1305)

âœ… So:

Yes, the Pre-Master Secret is the same for both client & server.

They arrive at it independently (never transmitted) thanks to DH math.

The Master Secret is then derived identically by both using the PRF/HKDF and random nonces.


=====================================================================================================
ğŸ”‘ 1. Pre-Master Secret (PMS)

RSA key exchange (TLS 1.2 only):

Client generates the PMS (random 48 bytes), encrypts it with the serverâ€™s public key, sends it in ClientKeyExchange.

Server decrypts it with its private key.
âœ… Now both have the same PMS.

(EC)DHE key exchange (TLS 1.2 & 1.3):

Both client & server generate ephemeral key pairs.

They exchange the public part (ServerKeyExchange in TLS 1.2, key_share extension in TLS 1.3).

Each side does the Diffie-Hellman math with its private key and the otherâ€™s public key.
âœ… Result: shared PMS that never goes over the wire.

ğŸ” 2. Master Secret (TLS 1.2) / Handshake Secrets (TLS 1.3)

In TLS 1.2:

PMS â†’ Master Secret via PRF:

master_secret = PRF(PMS, "master secret",
                    ClientRandom + ServerRandom) [48 bytes]


In TLS 1.3:

PMS goes into HKDF extract/expand chain (early secret â†’ handshake secret â†’ master secret).

No single â€œmaster secret,â€ but functionally the same idea.

ğŸ”§ 3. Key Expansion

From the master secret, session keys are derived.

TLS 1.2 (with AES + HMAC):
PRF expands to multiple keys:

client_write_MAC_key
server_write_MAC_key
client_write_key
server_write_key
client_IV
server_IV


â†’ Thatâ€™s 4 or 6 keys, depending on cipher (6 if separate MAC, 4 if AEAD).

TLS 1.3:
Cleaner design with HKDF. From master secret, we derive:

client_application_traffic_secret
server_application_traffic_secret
â†’ expanded into encryption keys & IVs (per AEAD)


No separate MAC keys anymore, since AEAD (e.g., AES-GCM, ChaCha20-Poly1305) handles both encryption + integrity.

ğŸ“¦ 4. Data Transmission

After this, both sides have identical symmetric keys.

All application data is encrypted & authenticated with those keys (per direction).

âœ… So yes â€” PMS â†’ Master Secret â†’ {4â€“6 keys in TLS 1.2, or AEAD traffic keys in TLS 1.3}.

Do you want me to also draw the full key schedule diagram for TLS 1.2 and TLS 1.3 (step by step arrows showing derivation), like we did for the handshake?

**

==============================
TLS 1.2 Key Schedule
(ClientHello)   ClientRandom ------------------â”
(ServerHello)   ServerRandom ------------------â”˜
                          â”‚
                          â–¼
            Pre-Master Secret (PMS)
                          â”‚
                          â–¼
     Master Secret = PRF(PMS, "master secret",
                         ClientRandom + ServerRandom)
                          â”‚
                          â–¼
   Key Block = PRF(MasterSecret, "key expansion",
                   ServerRandom + ClientRandom)
                          â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼                           â–¼                           â–¼
 client_write_MAC_key   server_write_MAC_key      (if using CBC+HMAC)
 client_write_key       server_write_key          (AES/3DES key)
 client_IV              server_IV                 (IV for AES-CBC, etc.)
==============================================================================**

TLS 1.3 Key Schedule

Early Secret (from PSK or 0) 
        â”‚
        â–¼
Handshake Secret = HKDF-Extract(DH(PMS), Early Secret)
        â”‚
        â”œâ”€â”€> Client Handshake Traffic Secret
        â”‚         â”‚
        â”‚         â””â”€â”€> Expanded into client handshake key + IV
        â”‚
        â””â”€â”€> Server Handshake Traffic Secret
                  â”‚
                  â””â”€â”€> Expanded into server handshake key + IV

(Handshake finished â†’ derive application secrets)

Master Secret = HKDF-Extract(0, Handshake Secret)
        â”‚
        â”œâ”€â”€> Client Application Traffic Secret
        â”‚         â”‚
        â”‚         â””â”€â”€> Expanded into client app key + IV
        â”‚
        â””â”€â”€> Server Application Traffic Secret
                  â”‚
                  â””â”€â”€> Expanded into server app key + IV



